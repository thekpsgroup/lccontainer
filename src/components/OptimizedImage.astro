---
export interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  class?: string;
  loading?: 'lazy' | 'eager';
  priority?: boolean;
  sizes?: string;
  placeholder?: 'blur' | 'dominant-color' | 'none';
}

const {
  src,
  alt,
  width = 800,
  height = 600,
  class: className = '',
  loading = 'lazy',
  priority = false,
  sizes = '100vw',
  placeholder = 'none'
} = Astro.props;

// Generate optimized image URLs
const baseUrl = src.startsWith('http') ? src : src;
const imageId = src.split('/').pop()?.split('.')[0] || 'image';

// Responsive image sizes
const responsiveSizes = [
  { width: 400, height: 300 },
  { width: 800, height: 600 },
  { width: 1200, height: 900 },
  { width: 1600, height: 1200 }
];

// Generate srcset for different formats
const generateSrcSet = (format: string) => {
  return responsiveSizes
    .map(size => `${baseUrl}?w=${size.width}&h=${size.height}&f=${format} ${size.width}w`)
    .join(', ');
};

// Generate picture element with multiple formats
const webpSrcSet = generateSrcSet('webp');
const avifSrcSet = generateSrcSet('avif');
const jpegSrcSet = generateSrcSet('jpeg');

// Lazy loading optimization
const loadingAttr = priority ? 'eager' : loading;
const fetchPriority = priority ? 'high' : 'auto';

// Generate placeholder
const placeholderUrl = placeholder === 'blur' 
  ? `${baseUrl}?w=20&h=20&f=webp&q=10&blur=10`
  : '';

// CSS for aspect ratio and loading optimization
const aspectRatio = height / width * 100;
---

<style>
  .optimized-image-container {
    position: relative;
    overflow: hidden;
    background: linear-gradient(45deg, rgba(178,34,34,.1), transparent);
  }
  
  .optimized-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: opacity 0.3s ease;
  }
  
  .optimized-image.loading {
    opacity: 0;
  }
  
  .optimized-image.loaded {
    opacity: 1;
  }
  
  .placeholder {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
  }
  
  @keyframes shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
  }
  
  .image-wrapper {
    position: relative;
    width: 100%;
    height: 0;
  }
</style>

<div class={`optimized-image-container ${className}`}>
  <div class="image-wrapper" style={`padding-bottom: ${aspectRatio}%`}>
    {placeholder === 'blur' && placeholderUrl && (
      <img 
        src={placeholderUrl} 
        alt="" 
        class="optimized-image placeholder" 
        aria-hidden="true"
        loading="eager"
      />
    )}
    
    <picture>
      <!-- AVIF format (best compression) -->
      <source 
        type="image/avif" 
        srcset={avifSrcSet}
        sizes={sizes}
      />
      
      <!-- WebP format (good compression) -->
      <source 
        type="image/webp" 
        srcset={webpSrcSet}
        sizes={sizes}
      />
      
      <!-- JPEG fallback -->
      <img 
        src={baseUrl}
        srcset={jpegSrcSet}
        sizes={sizes}
        alt={alt}
        width={width}
        height={height}
        loading={loadingAttr}
        fetchpriority={fetchPriority}
        class="optimized-image loading"
        decoding="async"
        onload="this.classList.remove('loading'); this.classList.add('loaded');"
        onerror="this.style.display='none'; this.nextElementSibling?.style.display='block';"
      />
    </picture>
    
    <!-- Fallback for failed images -->
    <div class="placeholder" style="display: none;">
      <div class="flex items-center justify-center h-full text-ink-muted">
        <svg class="w-12 h-12" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd" />
        </svg>
      </div>
    </div>
  </div>
</div>

<script>
  // Intersection Observer for lazy loading optimization
  if ('IntersectionObserver' in window) {
    const imageObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          const picture = img.closest('picture');
          
          // Preload the image
          if (picture) {
            const sources = picture.querySelectorAll('source');
            sources.forEach(source => {
              if (source.srcset) {
                const link = document.createElement('link');
                link.rel = 'preload';
                link.as = 'image';
                link.href = source.srcset;
                link.imagesrcset = source.srcset;
                link.imagesizes = source.sizes || '';
                document.head.appendChild(link);
              }
            });
          }
          
          // Load the image
          if (img.dataset.src) {
            img.src = img.dataset.src;
            img.removeAttribute('data-src');
          }
          
          observer.unobserve(img);
        }
      });
    }, {
      rootMargin: '50px 0px',
      threshold: 0.01
    });
    
    // Observe all lazy images
    document.addEventListener('DOMContentLoaded', () => {
      const lazyImages = document.querySelectorAll('img[loading="lazy"]');
      lazyImages.forEach(img => imageObserver.observe(img));
    });
  }
  
  // Preload critical images
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', preloadCriticalImages);
  } else {
    preloadCriticalImages();
  }
  
  function preloadCriticalImages() {
    const criticalImages = document.querySelectorAll('img[fetchpriority="high"]');
    criticalImages.forEach(img => {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.as = 'image';
      link.href = img.src;
      document.head.appendChild(link);
    });
  }
</script>
