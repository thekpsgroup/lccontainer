---
export interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  aspectRatio?: string;
  priority?: boolean;
  quality?: number;
  class?: string;
  sizes?: string;
  loading?: "lazy" | "eager";
  decoding?: "async" | "sync" | "auto";
  fetchpriority?: "high" | "low" | "auto";
  blurDataURL?: string;
  placeholder?: "blur" | "empty";
}

const {
  src,
  alt,
  width,
  height,
  aspectRatio,
  priority = false,
  quality = 80,
  class: className,
  sizes = "100vw",
  loading = "lazy",
  decoding = "async",
  fetchpriority,
  blurDataURL,
  placeholder = "empty",
} = Astro.props;

// Generate responsive image sources
const generateSources = (originalSrc: string) => {
  const sources = [];
  const baseName = originalSrc.replace(/\.[^/.]+$/, "");
  const extension = originalSrc.split(".").pop()?.toLowerCase();

  // Only include WebP sources if this isn't already a WebP file
  // Note: We're using fallback approach - if WebP files don't exist,
  // the browser will gracefully fall back to the original format
  if (extension !== "webp") {
    sources.push({
      type: "image/webp",
      srcset: `${baseName}.webp`,
    });
  }

  // Original format as fallback (always include this)
  sources.push({
    type: `image/${extension === "jpg" ? "jpeg" : extension}`,
    srcset: originalSrc,
  });

  return sources;
};

// Generate blur placeholder
const generateBlurPlaceholder = () => {
  if (blurDataURL) return blurDataURL;

  // Simple SVG blur placeholder based on aspect ratio
  const aspectRatioValue =
    aspectRatio || (width && height ? `${width}/${height}` : "16/9");
  const [w, h] = aspectRatioValue.split("/").map(Number);

  return `data:image/svg+xml;base64,${btoa(`
    <svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <filter id="blur">
          <feGaussianBlur stdDeviation="10"/>
        </filter>
      </defs>
      <rect width="100%" height="100%" fill="#f3f4f6" filter="url(#blur)"/>
    </svg>
  `)}`;
};

// Determine loading strategy
const isPriority = priority || fetchpriority === "high";
const actualLoading = isPriority ? "eager" : loading;
const actualFetchPriority = fetchpriority || (isPriority ? "high" : "auto");

// Generate style for aspect ratio
const style = aspectRatio ? `--aspect-ratio: ${aspectRatio};` : "";

const sources = generateSources(src);
const blurPlaceholder =
  placeholder === "blur" ? generateBlurPlaceholder() : null;
---

<picture class:list={["smart-image", className]}>
  {
    sources.map((source, index) => (
      <source srcset={source.srcset} sizes={sizes} type={source.type} />
    ))
  }

  <img
    src={src}
    alt={alt}
    width={width}
    height={height}
    loading={actualLoading}
    decoding={decoding}
    fetchpriority={actualFetchPriority}
    style={style}
    class:list={[
      "smart-image__img",
      {
        "aspect-ratio-box": aspectRatio,
        "blur-placeholder": placeholder === "blur",
      },
    ]}
    data-blur-src={blurPlaceholder}
  />
</picture>

<style>
  .smart-image {
    display: block;
    position: relative;
    overflow: hidden;
  }

  .smart-image__img {
    width: 100%;
    height: auto;
    display: block;
    transition: opacity 0.3s ease;
  }

  /* Aspect ratio container */
  .aspect-ratio-box {
    aspect-ratio: var(--aspect-ratio, auto);
    object-fit: cover;
  }

  /* Blur placeholder effect */
  .blur-placeholder {
    filter: blur(10px);
    transform: scale(1.1);
  }

  .blur-placeholder.loaded {
    filter: blur(0);
    transform: scale(1);
  }

  /* Intersection Observer for lazy loading */
  .smart-image[data-observer] .smart-image__img {
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .smart-image[data-observer].visible .smart-image__img {
    opacity: 1;
  }

  /* Performance optimizations */
  @media (prefers-reduced-motion: reduce) {
    .smart-image__img,
    .blur-placeholder {
      transition: none;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .blur-placeholder {
      filter: none;
      transform: none;
    }
  }
</style>

<script>
  // Intersection Observer for enhanced lazy loading
  class SmartImageObserver {
    private observer: IntersectionObserver;

    constructor() {
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const picture = entry.target as HTMLElement;
              const img = picture.querySelector("img");

              if (img) {
                // Add visible class for smooth transition
                picture.classList.add("visible");

                // Handle blur placeholder
                if (img.classList.contains("blur-placeholder")) {
                  img.classList.add("loaded");
                }
              }

              // Stop observing this element
              this.observer.unobserve(picture);
            }
          });
        },
        {
          rootMargin: "50px",
          threshold: 0.1,
        }
      );
    }

    observe(element: HTMLElement) {
      element.setAttribute("data-observer", "true");
      this.observer.observe(element);
    }
  }

  // Initialize observers for lazy-loaded images
  document.addEventListener("DOMContentLoaded", () => {
    const smartImages = document.querySelectorAll(
      ".smart-image:not([data-observer])"
    );

    if (smartImages.length > 0) {
      const observer = new SmartImageObserver();

      smartImages.forEach((img) => {
        // Only observe images that aren't already priority loaded
        if (!img.querySelector('img[loading="eager"]')) {
          observer.observe(img as HTMLElement);
        }
      });
    }
  });

  // Performance monitoring
  if ("PerformanceObserver" in window) {
    try {
      const observer = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.entryType === "largest-contentful-paint") {
            console.log("LCP:", entry.startTime);
          }
        });
      });
      observer.observe({ entryTypes: ["largest-contentful-paint"] });
    } catch (e) {
      // Performance observer not supported
    }
  }
</script>
